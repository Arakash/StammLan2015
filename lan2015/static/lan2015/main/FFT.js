// Generated by CoffeeScript 1.8.0
(function() {
  var FFT, FFT_SIZE, LOG;

  if (window.stammlan == null) {
    window.stammlan = {};
  }

  FFT_SIZE = 1024;

  LOG = 10;

  window.stammlan.FFT = FFT = (function() {
    FFT.prototype.hamming = [];

    FFT.prototype.reversed = [];

    FFT.prototype.roots = [];

    FFT.prototype.fft = [];

    function FFT() {
      var n, _i, _j, _k, _l, _ref;
      for (n = _i = 0; 0 <= FFT_SIZE ? _i < FFT_SIZE : _i > FFT_SIZE; n = 0 <= FFT_SIZE ? ++_i : --_i) {
        this.hamming.push(1 - 0.85 * Math.cos(2 * Math.PI * n / FFT_SIZE));
      }
      for (n = _j = 0; 0 <= FFT_SIZE ? _j < FFT_SIZE : _j > FFT_SIZE; n = 0 <= FFT_SIZE ? ++_j : --_j) {
        this.reversed.push(this.bitReverse(n));
      }
      for (n = _k = 0, _ref = FFT_SIZE / 2; 0 <= _ref ? _k < _ref : _k > _ref; n = 0 <= _ref ? ++_k : --_k) {
        this.roots.push(math.exp(math.complex(0, 2 * Math.PI * n / FFT_SIZE)));
      }
      for (n = _l = 0; 0 <= FFT_SIZE ? _l < FFT_SIZE : _l > FFT_SIZE; n = 0 <= FFT_SIZE ? ++_l : --_l) {
        this.fft.push(math.complex(0));
      }
    }

    FFT.prototype.calcFreq = function(data) {
      var freq, n, _i, _j, _ref;
      freq = new Array(FFT_SIZE / 2);
      for (n = _i = 0; 0 <= FFT_SIZE ? _i < FFT_SIZE : _i > FFT_SIZE; n = 0 <= FFT_SIZE ? ++_i : --_i) {
        this.fft[this.reversed[n]].re = data[n] * this.hamming[n];
        this.fft[this.reversed[n]].im = 0;
      }
      this.doFFT(this.fft);
      for (n = _j = 1, _ref = FFT_SIZE / 2; 1 <= _ref ? _j < _ref : _j > _ref; n = 1 <= _ref ? ++_j : --_j) {
        freq[n - 1] = 2 * math.abs(this.fft[n]) / FFT_SIZE;
      }
      freq[FFT_SIZE / 2 - 1] = math.abs(this.fft[FFT_SIZE / 2]) / FFT_SIZE;
      return freq;
    };

    FFT.prototype.doFFT = function(a) {
      var b, even, g, half, inv, odd, r, _results;
      half = 1;
      inv = FFT_SIZE / 2;
      _results = [];
      while (inv > 0) {
        g = 0;
        while (g < FFT_SIZE) {
          b = 0;
          r = 0;
          while (b < half) {
            even = math.complex(a[g + b]);
            odd = math.multiply(this.roots[r], a[g + half + b]);
            a[g + b] = math.add(even, odd);
            a[g + half + b] = math.subtract(even, odd);
            b++;
            r += inv;
          }
          g += half << 1;
        }
        half <<= 1;
        _results.push(inv >>= 1);
      }
      return _results;
    };

    FFT.prototype.bitReverse = function(x) {
      var n, y, _i;
      y = 0;
      for (n = _i = LOG; LOG <= 0 ? _i < 0 : _i > 0; n = LOG <= 0 ? ++_i : --_i) {
        y = (y << 1) | (x & 1);
        x >>= 1;
      }
      return y;
    };

    return FFT;

  })();

}).call(this);

//# sourceMappingURL=FFT.js.map
